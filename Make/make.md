#Linux下makefile

- 参考[跟我一起写 Makefile](http://blog.csdn.net/haoel/article/details/2886/)

- makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作

- 编译时，**编译器**需要的是语法的正确，函数与变量声明的正确（只检测声明）；链接时，主要是链接函数和全局变量，链接器不管源文件，只管中间的目标文件（寻找函数显示）

- 大多时候，编译器的生成的中间文件，即目标文件太多，链接却要指出目标文件名，对于编译不方便。

- configure是一个shell脚本，一般用来生成Makefile，为下一步的编译做准备，在configure后加上参数来对安装进项控制。例如./configure --prefix=/usr 即将软件安装在/usr下面

- make，即编译，大多数的源代码包都要经过编译。如果make过程出现error，仔细研究错误代码

- make install，用这条命令进行安装

- = make会将整个makefile展开后，再决定变量的值，变量的值将会是整个makefile中最后被指定的值； :=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。最好使用:=

- wildcard被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表，即搜索文件 

- include 暂停读取当前的 Makefile,而转去读取include指定的一个或者多个文件,完成以后再继续当前 Makefile 的读取。-include忽略文件不存在或者无法创建时的错误，make继续执行

- “$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]

- notdir 从变量中取出非目录部分

- addsuffix [suffix] [names] 将后缀[suffix]加到[names]每个单词后面

- addprefix [prefix][names] 将前缀[suffix]加到[names]每个单词前面

- strip [string] 去掉[string]字符串开头和结尾的空字符

- sort [list] 对[string]中的单词排序(升序)
- foreach [var],[list],[text] 将参数[list]的单词逐一取出，放到[var]指定的变量中，再执行[text]表达式

- 没有前缀，输出执行的命令以及结果，出错停止执行；前缀@，命令正常执行，但只输出命令执行结果，出错则停止；前缀-，命令执行有错的话，忽略错误，继续执行

- 竖线"|"，对于需要执行某个或某些规则，但不能引起生成目标被重新生成，需要命令前提目标。竖线左边的目标是正常前提目标，右边的目标是命令前提目标。命令前提目标往往是目录路径

- $@目标文件，$^所有依赖文件，$<第一个依赖文件

- %字符，$(objects): %.o :%.c。%.o取完值后，%.c的%取与之前相同。objects: foo.o bar.o, 则foo.o:foo.c与bar.o:bar.c

- 伪目标.PHONY并不是实际存在的文件，只是一个标签。make无法生成它的依赖和决定是否执行。对于无依赖文件的目标名，例如clean，每次make都会自动执行；但是如果文件夹下存在clean文件，则系统认为其是最新文件，则将无法执行目标中的命令了。通过.PHONY表示无论是否有这个文件，必须执行这个目标。作用：避免和同名文件冲突，改善性能。

- 伪目标一般没有依赖文件，但是可为伪目标指定所依赖文件